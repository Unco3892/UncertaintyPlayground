---
title: "EM-VAE"
toc: true
toc-location: left
format: 
  html:
    number-sections: true
    html-math-method: katex
    code-tools: true
    code-fold: false
    code-link: true
    self-contained: true
execute: 
  warning: false
  message: false
---

## Algorithms: With missing inputs

### Algorithm 12
![some](assets/algos/algo_12.png)

```{r}
# set seed the number of instances
set.seed(123)
N <- 100
# initialize the vectors where half of x1 is NA
x1 <- rep(NA, N)
x1[1:(N/2)] <- rnorm(N/2)
x2 <- rnorm(N)
y <- rnorm(N)
L <- 20
```

```{r}
c(1,2,3)
```

Consider the following formula:
```latex
\zeta^* = \arg\min_\zeta \sum_{j=1}^{NR} \tilde{w}_{j}\{\tilde{y}_j - f_\zeta(\tilde{z}_j)\}^2
```
Now in my R code, I'm running a linear regression with `caret`, where these are the equivalent of the following variables:
- `\tilde{y}` is represented by a variable called `y_comp`.
- `\tilde{w}` is represented by a variable called `w_comp`
- `f_\zeta(\tilde{z}_j)`is represented by a variable called `hidden_node`
Here's the R code below:
```R
  modR <- caret::train(
    y_comp ~ .,
    data.frame(hidden_node, y_comp),
    # method = "Rborist", #rf
    method = "lm",
    # Rborist
    trControl = trainControl(method = "none"),
    weights = w_comp
  )
```
Now, consider the following formula:
```
(\sigma^{*})^2 = \frac{1}{NR} \sum_{j=1}^{NR} \tilde{w}_{j}\{\tilde{y}_j - f_{\zeta^*}(\tilde{z}_j)\}^2 
```

To implement the given formula, you first need to calculate the residuals, i.e., the differences between the observed values `y_comp` and the predicted values `f_{\zeta^*}(\tilde{z}_j)` obtained from the linear regression model `modR`. Then, you need to calculate the weighted sum of squared residuals and divide it by `NR`.

Here's how you can do this in R:

```{r}
# # Calculate the predicted values using the trained model
# pred_values <- predict(modR, newdata = data.frame(hidden_node))

# # Calculate the residuals
# residuals <- y_comp - pred_values

# # Calculate the weighted sum of squared residuals
# weighted_sum_sq_residuals <- sum(w_comp * residuals^2)

# # Calculate NR
# NR <- length(y_comp)

# # Calculate (\sigma^{*})^2
# sigma_sq <- weighted_sum_sq_residuals / NR

# sigma_sq
```

# Make a Quarto file for the different parts of the algorithm which can later be used to explain the code 

```{r}
#hist(a[1,], main=paste0("Histogram of row ", 1), xlab="Value")
#plot(density(a[1,]), main=paste0("Density plot of row ", 1), xlab="Value", ylab="Density")
```